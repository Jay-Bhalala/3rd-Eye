{"version":3,"sources":["../src/index.ts","../src/logger.ts","../src/telemetry.ts","../src/scanner.ts","../src/schema.ts","../src/registrar.ts","../src/watcher.ts"],"sourcesContent":["// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 3rd Eye SDK â€” Main Entry Point\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n//\r\n//   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\n//   â”‚  init()  â”‚ â”€â”€â–· â”‚ scanDOM  â”‚ â”€â”€â–· â”‚ fetchSchemas â”‚ â”€â”€â–· â”‚ register   â”‚\r\n//   â”‚          â”‚     â”‚          â”‚     â”‚              â”‚     â”‚ Tools      â”‚\r\n//   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n//        â”‚                                                       â”‚\r\n//        â–½                                                       â–½\r\n//   Feature Detection                                    navigator.modelContext\r\n//   + Config Resolution                                  .registerTool()\r\n//   + provideContext()                                         â”‚\r\n//                                                              â–½\r\n//                                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\r\n//                                                    â”‚  Live Watcher      â”‚\r\n//                                                    â”‚  (MutationObserver â”‚\r\n//                                                    â”‚  + SPA navigation) â”‚\r\n//                                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\r\n//\r\n// 8-Stage Architecture:\r\n//   1. Feature Detect      â†’ Check navigator.modelContext\r\n//   2. Provide Context     â†’ Send page metadata (title, URL, description)\r\n//   3. Smart Scan          â†’ Find forms + buttons\r\n//   4. Brain Generation    â†’ API â†’ Schemas + Annotations\r\n//   5. Register            â†’ registerTool() with annotations\r\n//   6. Live Watcher        â†’ MutationObserver + SPA events\r\n//   7. Un-Register         â†’ Remove stale tools (handled by watcher)\r\n//   8. Execute Wrapper     â†’ Intercept + User Confirmation + Telemetry\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nimport type { ThirdEyeConfig, ScannedElement, ToolSchema } from \"./types\";\r\nimport * as log from \"./logger\";\r\nimport { configureTelemetry, trackEvent } from \"./telemetry\";\r\nimport { scanDOM } from \"./scanner\";\r\nimport { fetchSchemas } from \"./schema\";\r\nimport { registerTools, unregisterAllTools } from \"./registrar\";\r\nimport { startWatching, stopWatching, isWatching } from \"./watcher\";\r\n\r\n// Re-export types for ESM consumers\r\nexport type { ThirdEyeConfig, ScannedElement, ToolSchema, ToolAnnotations } from \"./types\";\r\n\r\n// â”€â”€â”€ SDK Class â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/**\r\n * The 3rd Eye SDK singleton.\r\n *\r\n * Orchestrates the full 8-stage lifecycle:\r\n * 1. Configuration parsing & validation\r\n * 2. Feature detection (WebMCP / `navigator.modelContext`)\r\n * 3. Context provisioning (page metadata for agents)\r\n * 4. DOM scanning\r\n * 5. Schema generation (AI-first, local fallback)\r\n * 6. Tool registration with annotations + user confirmation\r\n * 7. Live watching (MutationObserver + SPA navigation)\r\n * 8. Cleanup & destroy\r\n *\r\n * @example\r\n * ```html\r\n * <!-- Auto-init via data attributes -->\r\n * <script src=\"3rdeye.min.js\" data-site-id=\"site_abc123\"></script>\r\n *\r\n * <!-- Or manual init -->\r\n * <script>\r\n *   ThirdEye.init({ siteId: \"site_abc123\", debug: true });\r\n * </script>\r\n * ```\r\n */\r\nexport class ThirdEyeSDK {\r\n    private config: ThirdEyeConfig | null = null;\r\n    private initialized = false;\r\n    private scannedElements: ScannedElement[] = [];\r\n    private registeredSchemas: ToolSchema[] = [];\r\n\r\n    // â”€â”€ Initialisation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n    /**\r\n     * Initialise the 3rd Eye SDK.\r\n     *\r\n     * This is the main entry point.  It performs feature detection, provides\r\n     * page context, scans the DOM, generates schemas, registers tools, and\r\n     * starts the live watcher.\r\n     *\r\n     * Safe to call multiple times â€” subsequent calls are no-ops.\r\n     *\r\n     * @param config - SDK configuration.  `siteId` is required.\r\n     */\r\n    async init(config: ThirdEyeConfig): Promise<void> {\r\n        if (this.initialized) {\r\n            log.warn(\"SDK already initialized.\");\r\n            return;\r\n        }\r\n\r\n        // â”€â”€ Validate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n        if (!config.siteId) {\r\n            log.error(\"Missing required `siteId`. Aborting.\");\r\n            return;\r\n        }\r\n\r\n        this.config = config;\r\n        this.initialized = true;\r\n\r\n        // â”€â”€ Configure subsystems â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n        log.setDebug(config.debug ?? false);\r\n        configureTelemetry(config.siteId, config.ingestUrl);\r\n\r\n        log.info(\"Initializing with config:\", config);\r\n        trackEvent(\"SDK_INIT\", { endpoint: config.endpoint });\r\n\r\n        // â”€â”€ Stage 1: Feature Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n        if (!navigator.modelContext) {\r\n            log.warn(\r\n                \"WebMCP not supported in this browser. Polyfill active.\",\r\n            );\r\n        }\r\n\r\n        // â”€â”€ Pipeline â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n        try {\r\n            // Stage 3: Scan the DOM\r\n            this.scannedElements = scanDOM();\r\n            trackEvent(\"SCAN_COMPLETE\", { elementCount: this.scannedElements.length });\r\n\r\n            if (this.scannedElements.length === 0) {\r\n                log.info(\"No actionable elements found. Nothing to register.\");\r\n                return;\r\n            }\r\n\r\n            // Stage 4: Generate schemas (AI-first, with annotations)\r\n            this.registeredSchemas = await fetchSchemas(\r\n                this.scannedElements,\r\n                config.endpoint,\r\n            );\r\n\r\n            // Stage 5: Register with WebMCP (annotations + user confirmation)\r\n            registerTools(this.registeredSchemas);\r\n\r\n            // Stage 6: Provide page context (after tools are registered)\r\n            this.providePageContext();\r\n\r\n            // Stage 7: Start live watcher (MutationObserver + SPA events)\r\n            const selectors = this.scannedElements.map((e) => e.selector);\r\n            startWatching(config, selectors);\r\n\r\n        } catch (err) {\r\n            // The SDK must NEVER crash the host page.\r\n            log.error(\"Pipeline error:\", err);\r\n        }\r\n    }\r\n\r\n    // â”€â”€ Context Provisioning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n    /**\r\n     * Send page-level metadata to AI agents via navigator.modelContext.\r\n     * Chrome's ProvideContextParams requires a `tools` array.\r\n     */\r\n    private providePageContext(): void {\r\n        if (!navigator.modelContext?.provideContext) return;\r\n\r\n        try {\r\n            const meta = document.querySelector<HTMLMetaElement>(\r\n                'meta[name=\"description\"]',\r\n            );\r\n\r\n            // Chrome's provideContext expects: { tools: [...], ... }\r\n            // We pass an empty tools array â€” tools are already registered\r\n            // via registerTool(). The context provides supplementary metadata.\r\n            navigator.modelContext.provideContext({\r\n                tools: [],\r\n                title: document.title,\r\n                url: window.location.href,\r\n                description: meta?.content ?? \"\",\r\n            });\r\n\r\n            log.info(\"ğŸ“„ Provided page context to AI agent\");\r\n        } catch (err) {\r\n            // provideContext may not be fully implemented yet â€” that's OK.\r\n            log.warn(\"provideContext not available:\", err);\r\n        }\r\n    }\r\n\r\n    // â”€â”€ Public Accessors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n    /**\r\n     * Re-scan the DOM and register any new tools.\r\n     *\r\n     * Useful for SPAs where the page content changes without a full reload.\r\n     */\r\n    async scan(): Promise<ScannedElement[]> {\r\n        if (!this.initialized || !this.config) {\r\n            log.warn(\"Cannot scan â€” SDK not initialized. Call init() first.\");\r\n            return [];\r\n        }\r\n\r\n        try {\r\n            this.scannedElements = scanDOM();\r\n            trackEvent(\"SCAN_COMPLETE\", { elementCount: this.scannedElements.length });\r\n\r\n            this.registeredSchemas = await fetchSchemas(\r\n                this.scannedElements,\r\n                this.config.endpoint,\r\n            );\r\n\r\n            registerTools(this.registeredSchemas);\r\n        } catch (err) {\r\n            log.error(\"Re-scan error:\", err);\r\n        }\r\n\r\n        return this.scannedElements;\r\n    }\r\n\r\n    /**\r\n     * Fully destroy the SDK: unregister all tools, stop the watcher,\r\n     * clear context, and reset state.\r\n     */\r\n    destroy(): void {\r\n        log.info(\"ğŸ’€ Destroying SDK...\");\r\n\r\n        // Stop the live watcher\r\n        if (isWatching()) {\r\n            stopWatching();\r\n        }\r\n\r\n        // Unregister all tools\r\n        unregisterAllTools();\r\n\r\n        // Clear context\r\n        if (navigator.modelContext?.clearContext) {\r\n            try {\r\n                navigator.modelContext.clearContext();\r\n                log.info(\"ğŸ§¹ Cleared page context\");\r\n            } catch {\r\n                // Best-effort cleanup.\r\n            }\r\n        }\r\n\r\n        // Reset state\r\n        this.config = null;\r\n        this.initialized = false;\r\n        this.scannedElements = [];\r\n        this.registeredSchemas = [];\r\n\r\n        log.info(\"ğŸ’€ SDK destroyed\");\r\n    }\r\n\r\n    /** Whether the SDK has been initialised. */\r\n    isInitialized(): boolean {\r\n        return this.initialized;\r\n    }\r\n\r\n    /** The current configuration, or `null` if not initialised. */\r\n    getConfig(): ThirdEyeConfig | null {\r\n        return this.config;\r\n    }\r\n\r\n    /** The elements found during the last scan. */\r\n    getScannedElements(): ScannedElement[] {\r\n        return this.scannedElements;\r\n    }\r\n\r\n    /** The schemas generated from the last scan. */\r\n    getSchemas(): ToolSchema[] {\r\n        return this.registeredSchemas;\r\n    }\r\n\r\n    /** Whether the live DOM watcher is currently active. */\r\n    isWatcherActive(): boolean {\r\n        return isWatching();\r\n    }\r\n}\r\n\r\n// â”€â”€â”€ Singleton & Convenience Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nconst instance = new ThirdEyeSDK();\r\n\r\nexport const init = instance.init.bind(instance);\r\nexport const scan = instance.scan.bind(instance);\r\nexport const destroy = instance.destroy.bind(instance);\r\nexport const isInitialized = instance.isInitialized.bind(instance);\r\nexport const getConfig = instance.getConfig.bind(instance);\r\nexport const getScannedElements = instance.getScannedElements.bind(instance);\r\nexport const getSchemas = instance.getSchemas.bind(instance);\r\nexport const isWatcherActive = instance.isWatcherActive.bind(instance);\r\n\r\nexport default instance;\r\n\r\n// â”€â”€â”€ Auto-initialisation from <script> data attributes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n//\r\n// When loaded as a <script> tag:\r\n//   <script src=\"3rdeye.min.js\" data-site-id=\"site_abc\" data-debug=\"true\"></script>\r\n//\r\n// The SDK will automatically initialize without any additional JS.\r\n\r\nif (typeof document !== \"undefined\" && document.currentScript) {\r\n    const script = document.currentScript;\r\n    const siteId = script.getAttribute(\"data-site-id\");\r\n\r\n    if (siteId) {\r\n        const config: ThirdEyeConfig = {\r\n            siteId,\r\n            endpoint: script.getAttribute(\"data-endpoint\") ?? undefined,\r\n            ingestUrl: script.getAttribute(\"data-ingest-url\") ?? undefined,\r\n            debug: script.getAttribute(\"data-debug\") === \"true\",\r\n        };\r\n\r\n        // Wait for DOM to be fully parsed before scanning.\r\n        if (document.readyState === \"loading\") {\r\n            document.addEventListener(\"DOMContentLoaded\", () => {\r\n                instance.init(config);\r\n            });\r\n        } else {\r\n            // DOM already ready (script was deferred or dynamically injected).\r\n            instance.init(config);\r\n        }\r\n    }\r\n}\r\n","// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 3rd Eye SDK â€” Logger\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// A thin, debug-aware logging utility.  All messages are prefixed with\r\n// `[3rdEye]` so they are easy to find in DevTools.\r\n//\r\n// When `debug` mode is OFF, only `warn` and `error` calls produce output.\r\n// When `debug` mode is ON, `info` calls are also printed.\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nconst PREFIX = \"[3rdEye]\";\r\n\r\nlet debugEnabled = false;\r\n\r\n/**\r\n * Enable or disable verbose debug logging.\r\n *\r\n * @param enabled - `true` to print `info`-level messages; `false` to suppress.\r\n */\r\nexport function setDebug(enabled: boolean): void {\r\n    debugEnabled = enabled;\r\n}\r\n\r\n/**\r\n * Log an informational message (only visible when debug mode is ON).\r\n */\r\nexport function info(...args: unknown[]): void {\r\n    if (debugEnabled) {\r\n        console.log(PREFIX, ...args);\r\n    }\r\n}\r\n\r\n/**\r\n * Log a warning (always visible).\r\n */\r\nexport function warn(...args: unknown[]): void {\r\n    console.warn(PREFIX, ...args);\r\n}\r\n\r\n/**\r\n * Log an error (always visible).\r\n */\r\nexport function error(...args: unknown[]): void {\r\n    console.error(PREFIX, ...args);\r\n}\r\n","// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 3rd Eye SDK â€” Telemetry\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Lightweight event tracking using `navigator.sendBeacon` (preferred) with\r\n// a `fetch` fallback.  Every event is enriched with siteId, timestamp, and\r\n// the browser's User-Agent string.\r\n//\r\n// Telemetry calls are fire-and-forget â€” they NEVER throw, log on failure, and\r\n// never block the main thread or the host page.\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nimport type { TelemetryEvent, TelemetryEventName } from \"./types\";\r\nimport * as log from \"./logger\";\r\n\r\n/** Default ingest endpoint (overridable via config). */\r\nconst DEFAULT_INGEST_URL = \"https://api.3rdeye.dev/api/v1/telemetry\";\r\n\r\nlet siteId = \"\";\r\nlet ingestUrl = DEFAULT_INGEST_URL;\r\n\r\n/**\r\n * Configure the telemetry subsystem.\r\n *\r\n * Must be called once during SDK initialisation before any events are tracked.\r\n *\r\n * @param id  - The site identifier from the dashboard.\r\n * @param url - (Optional) Override for the ingest endpoint.\r\n */\r\nexport function configureTelemetry(id: string, url?: string): void {\r\n    siteId = id;\r\n    if (url) ingestUrl = url;\r\n}\r\n\r\n/**\r\n * Track a telemetry event.\r\n *\r\n * Builds a {@link TelemetryEvent} payload, serialises it to JSON, and\r\n * delivers it via `navigator.sendBeacon`.  If the Beacon API is\r\n * unavailable, falls back to a `keepalive` `fetch` POST.\r\n *\r\n * @param name - The event name (e.g. `\"TOOL_ATTEMPT\"`).\r\n * @param data - Optional key/value bag of event-specific data.\r\n */\r\nexport function trackEvent(\r\n    name: TelemetryEventName,\r\n    data?: Record<string, unknown>,\r\n): void {\r\n    try {\r\n        const event: TelemetryEvent = {\r\n            event: name,\r\n            siteId,\r\n            timestamp: new Date().toISOString(),\r\n            userAgent: navigator.userAgent,\r\n            data,\r\n        };\r\n\r\n        const payload = JSON.stringify(event);\r\n\r\n        // Prefer sendBeacon â€” it survives page unloads and doesn't block.\r\n        if (navigator.sendBeacon) {\r\n            const blob = new Blob([payload], { type: \"application/json\" });\r\n            navigator.sendBeacon(ingestUrl, blob);\r\n        } else {\r\n            // Fallback for older browsers.\r\n            fetch(ingestUrl, {\r\n                method: \"POST\",\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: payload,\r\n                keepalive: true,\r\n            }).catch(() => {\r\n                /* swallow â€” telemetry must never crash the host page */\r\n            });\r\n        }\r\n\r\n        log.info(`ğŸ“¡ Telemetry â†’ ${name}`, data ?? \"\");\r\n    } catch {\r\n        // Absolute last-resort protection â€” telemetry must NEVER throw.\r\n        log.warn(\"Telemetry delivery failed for event:\", name);\r\n    }\r\n}\r\n","// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 3rd Eye SDK â€” DOM Scanner\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Traverses the live DOM and returns a lightweight, serialisable inventory of\r\n// \"actionable elements\" â€” forms and buttons that an AI agent can interact with.\r\n//\r\n// The scanner runs once at init and can be re-invoked if the page mutates\r\n// (e.g. SPA navigation).  It produces ZERO side-effects on the DOM.\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nimport type { ScannedElement, ScannedInput, ToolAnnotations } from \"./types\";\r\nimport * as log from \"./logger\";\r\n\r\n// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/**\r\n * Build a unique CSS selector for a given element.\r\n *\r\n * Prefers `#id` selectors.  Falls back to a positional `tag:nth-of-type(n)`.\r\n */\r\nfunction buildSelector(el: Element): string {\r\n    if (el.id) return `#${el.id}`;\r\n\r\n    const tag = el.tagName.toLowerCase();\r\n    const parent = el.parentElement;\r\n\r\n    if (!parent) return tag;\r\n\r\n    const siblings = Array.from(parent.children).filter(\r\n        (s) => s.tagName === el.tagName,\r\n    );\r\n\r\n    if (siblings.length === 1) return `${buildSelector(parent)} > ${tag}`;\r\n\r\n    const idx = siblings.indexOf(el) + 1;\r\n    return `${buildSelector(parent)} > ${tag}:nth-of-type(${idx})`;\r\n}\r\n\r\n/**\r\n * Find the `<label>` text associated with an input via `for` attribute or by\r\n * walking up to a wrapping `<label>`.\r\n */\r\nfunction findLabelText(input: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement): string | undefined {\r\n    // Explicit <label for=\"â€¦\">\r\n    if (input.id) {\r\n        const label = document.querySelector<HTMLLabelElement>(`label[for=\"${input.id}\"]`);\r\n        if (label) return label.textContent?.trim();\r\n    }\r\n\r\n    // Wrapping <label>\r\n    const parent = input.closest(\"label\");\r\n    if (parent) return parent.textContent?.trim();\r\n\r\n    return undefined;\r\n}\r\n\r\n// â”€â”€â”€ Declarative Attribute Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/** Selectors that are already covered by `scanForms()` and `scanButtons()`. */\r\nconst STANDARD_SELECTORS = 'form, button, [role=\"button\"], input[type=\"button\"], input[type=\"submit\"]';\r\n\r\n/**\r\n * Check if an element has `data-tool-ignore` and should be excluded.\r\n */\r\nfunction isIgnored(el: Element): boolean {\r\n    return el.hasAttribute(\"data-tool-ignore\");\r\n}\r\n\r\n/**\r\n * Read `data-tool-*` declarative attributes from any element and return\r\n * the override fields for a {@link ScannedElement}.\r\n */\r\nfunction readToolAttributes(el: Element): {\r\n    overrideName?: string;\r\n    overrideDescription?: string;\r\n    overrideAnnotations?: ToolAnnotations;\r\n} {\r\n    const name = el.getAttribute(\"data-tool-name\") ?? undefined;\r\n    const description = el.getAttribute(\"data-tool-description\") ?? undefined;\r\n\r\n    // Build annotations only if at least one hint attribute is present\r\n    const hasReadOnly = el.hasAttribute(\"data-tool-readonly\");\r\n    const hasDestructive = el.hasAttribute(\"data-tool-destructive\");\r\n    const hasIdempotent = el.hasAttribute(\"data-tool-idempotent\");\r\n    const hasOpenWorld = el.hasAttribute(\"data-tool-open-world\");\r\n\r\n    let annotations: ToolAnnotations | undefined;\r\n    if (hasReadOnly || hasDestructive || hasIdempotent || hasOpenWorld) {\r\n        annotations = {};\r\n        if (hasReadOnly) annotations.readOnlyHint = true;\r\n        if (hasDestructive) annotations.destructiveHint = true;\r\n        if (hasIdempotent) annotations.idempotentHint = true;\r\n        if (hasOpenWorld) annotations.openWorldHint = true;\r\n    }\r\n\r\n    return {\r\n        overrideName: name,\r\n        overrideDescription: description,\r\n        overrideAnnotations: annotations,\r\n    };\r\n}\r\n\r\n// â”€â”€â”€ Scanners â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/**\r\n * Scan all `<form>` elements and return structured representations.\r\n */\r\nfunction scanForms(): ScannedElement[] {\r\n    const forms = document.querySelectorAll<HTMLFormElement>(\"form\");\r\n    const results: ScannedElement[] = [];\r\n\r\n    forms.forEach((form) => {\r\n        // Skip elements explicitly excluded by the developer\r\n        if (isIgnored(form)) return;\r\n\r\n        // Read declarative overrides from data-tool-* attributes\r\n        const overrides = readToolAttributes(form);\r\n\r\n        // Collect inputs, selects, and textareas\r\n        const inputEls = form.querySelectorAll<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>(\r\n            \"input, select, textarea\",\r\n        );\r\n\r\n        const inputs: ScannedInput[] = [];\r\n        inputEls.forEach((input) => {\r\n            // Skip hidden/submit/button types â€” they aren't user-facing parameters\r\n            if (input instanceof HTMLInputElement) {\r\n                const skip = [\"hidden\", \"submit\", \"button\", \"reset\", \"image\"];\r\n                if (skip.includes(input.type)) return;\r\n            }\r\n\r\n            const name = input.name || input.id || \"\";\r\n            if (!name) return; // Unnamed inputs can't be targeted\r\n\r\n            // Read optional data-tool-param override for parameter description\r\n            const overrideParamDescription =\r\n                input.getAttribute(\"data-tool-param\") ?? undefined;\r\n\r\n            inputs.push({\r\n                name,\r\n                inputType: input instanceof HTMLInputElement ? input.type : input.tagName.toLowerCase(),\r\n                required: input.required,\r\n                placeholder: input instanceof HTMLInputElement ? input.placeholder || undefined : undefined,\r\n                label: findLabelText(input),\r\n                overrideParamDescription,\r\n            });\r\n        });\r\n\r\n        results.push({\r\n            type: \"form\",\r\n            id: form.id || undefined,\r\n            selector: buildSelector(form),\r\n            action: form.action || undefined,\r\n            method: (form.method || \"GET\").toUpperCase(),\r\n            inputs,\r\n            ...overrides,\r\n        });\r\n    });\r\n\r\n    return results;\r\n}\r\n\r\n/**\r\n * Scan buttons with descriptive attributes (`aria-label`, meaningful `id`,\r\n * or visible text).\r\n */\r\nfunction scanButtons(): ScannedElement[] {\r\n    // Regular buttons + anchor elements with role=\"button\"\r\n    const candidates = document.querySelectorAll<HTMLElement>(\r\n        'button, [role=\"button\"], input[type=\"button\"], input[type=\"submit\"]',\r\n    );\r\n\r\n    const results: ScannedElement[] = [];\r\n\r\n    candidates.forEach((el) => {\r\n        // Skip elements explicitly excluded by the developer\r\n        if (isIgnored(el)) return;\r\n\r\n        // Read declarative overrides from data-tool-* attributes\r\n        const overrides = readToolAttributes(el);\r\n\r\n        const ariaLabel = el.getAttribute(\"aria-label\") ?? undefined;\r\n        const textContent = el.textContent?.trim() || undefined;\r\n        const id = el.id || undefined;\r\n\r\n        // Skip buttons with no semantic meaning â€” we can't generate a schema\r\n        // (unless the developer has provided a data-tool-name override)\r\n        if (!overrides.overrideName && !ariaLabel && !id && !textContent) return;\r\n\r\n        // Skip form-internal submit buttons (already captured by form scan)\r\n        if (el.closest(\"form\")) return;\r\n\r\n        results.push({\r\n            type: \"button\",\r\n            id,\r\n            selector: buildSelector(el),\r\n            ariaLabel,\r\n            textContent,\r\n            ...overrides,\r\n        });\r\n    });\r\n\r\n    return results;\r\n}\r\n\r\n/**\r\n * Scan elements that are NOT standard `<form>` or button elements but have\r\n * been explicitly annotated by the developer with `data-tool-name`.\r\n *\r\n * This catches `<div>`, `<a>`, `<span>`, and any other non-standard element.\r\n * They are treated as click-to-execute tools (type: \"button\").\r\n */\r\nfunction scanAnnotated(): ScannedElement[] {\r\n    const candidates = document.querySelectorAll<HTMLElement>(\"[data-tool-name]\");\r\n    const results: ScannedElement[] = [];\r\n\r\n    candidates.forEach((el) => {\r\n        // Skip elements explicitly excluded\r\n        if (isIgnored(el)) return;\r\n\r\n        // Skip elements already covered by scanForms() and scanButtons()\r\n        if (el.matches(STANDARD_SELECTORS) || el.closest(\"form\")) return;\r\n\r\n        const overrides = readToolAttributes(el);\r\n        const ariaLabel = el.getAttribute(\"aria-label\") ?? undefined;\r\n        const textContent = el.textContent?.trim() || undefined;\r\n        const id = el.id || undefined;\r\n\r\n        results.push({\r\n            type: \"button\",\r\n            id,\r\n            selector: buildSelector(el),\r\n            ariaLabel,\r\n            textContent,\r\n            ...overrides,\r\n        });\r\n    });\r\n\r\n    return results;\r\n}\r\n\r\n// â”€â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/**\r\n * Scan the current DOM for actionable elements.\r\n *\r\n * Discovers elements via three passes:\r\n *   1. Standard `<form>` elements\r\n *   2. Standard buttons (`<button>`, `[role=\"button\"]`, etc.)\r\n *   3. Non-standard elements annotated with `data-tool-name`\r\n *\r\n * All passes honour `data-tool-ignore` (excluded) and `data-tool-*`\r\n * declarative overrides for names, descriptions, and annotations.\r\n *\r\n * @returns An array of {@link ScannedElement} objects â€” lightweight JSON,\r\n *          safe to serialise and send to the schema generation API.\r\n */\r\nexport function scanDOM(): ScannedElement[] {\r\n    const forms = scanForms();\r\n    const buttons = scanButtons();\r\n    const annotated = scanAnnotated();\r\n\r\n    const all = [...forms, ...buttons, ...annotated];\r\n\r\n    log.info(\r\n        `ğŸ” Scanner found ${forms.length} form(s), ${buttons.length} button(s), and ${annotated.length} annotated element(s)`,\r\n        all,\r\n    );\r\n\r\n    return all;\r\n}\r\n","// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 3rd Eye SDK â€” Schema Generator (The \"Brain\" Connection)\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Converts scanned DOM elements into WebMCP-compatible tool schemas.\r\n//\r\n// STRATEGY:\r\n//   1. Try the 3rd Eye API first (AI-enhanced via GPT-4o-mini)\r\n//   2. Fall back to local generation if the API is unreachable or errors\r\n//   3. Cache results in localStorage to avoid redundant API calls\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nimport type { ScannedElement, ToolSchema, ToolInputSchema, ToolAnnotations } from \"./types\";\r\nimport * as log from \"./logger\";\r\n\r\n// â”€â”€â”€ Local Fallback Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/**\r\n * Convert a human-readable string to a snake_case tool name.\r\n */\r\nfunction toToolName(raw: string): string {\r\n    return raw\r\n        .toLowerCase()\r\n        .replace(/[^a-z0-9]+/g, \"_\")\r\n        .replace(/^_|_$/g, \"\");\r\n}\r\n\r\n/**\r\n * Generate a JSON Schema from a scanned form's inputs.\r\n */\r\nfunction inputsToSchema(element: ScannedElement): ToolInputSchema {\r\n    const properties: ToolInputSchema[\"properties\"] = {};\r\n    const required: string[] = [];\r\n\r\n    if (element.inputs) {\r\n        for (const input of element.inputs) {\r\n            properties[input.name] = {\r\n                type: input.inputType === \"number\" ? \"number\" : \"string\",\r\n                description:\r\n                    input.overrideParamDescription ||\r\n                    input.label ||\r\n                    input.placeholder ||\r\n                    `The ${input.name} field (${input.inputType})`,\r\n            };\r\n            if (input.required) required.push(input.name);\r\n        }\r\n    }\r\n\r\n    return { type: \"object\", properties, required };\r\n}\r\n\r\n/**\r\n * Infer annotations from a form's HTTP method.\r\n * GET â†’ read-only, POST/PUT â†’ open-world, DELETE â†’ destructive.\r\n */\r\nfunction inferFormAnnotations(method?: string): ToolAnnotations {\r\n    const m = (method ?? \"GET\").toUpperCase();\r\n    if (m === \"GET\") return { readOnlyHint: true, destructiveHint: false };\r\n    if (m === \"DELETE\") return { destructiveHint: true, readOnlyHint: false };\r\n    return { readOnlyHint: false, openWorldHint: true };\r\n}\r\n\r\nfunction schemaFromForm(element: ScannedElement): ToolSchema {\r\n    const name = element.overrideName ?? toToolName(element.id || \"unknown_form\");\r\n    const inputCount = element.inputs?.length ?? 0;\r\n    const description = element.overrideDescription ??\r\n        `Submit the \"${element.id || \"unknown\"}\" form (${element.method ?? \"GET\"}, ${inputCount} field${inputCount !== 1 ? \"s\" : \"\"})`;\r\n    const annotations = element.overrideAnnotations ?? inferFormAnnotations(element.method);\r\n\r\n    return {\r\n        name,\r\n        description,\r\n        parameters: inputsToSchema(element),\r\n        selector: element.selector,\r\n        elementType: \"form\",\r\n        annotations,\r\n    };\r\n}\r\n\r\n/**\r\n * Infer annotations from button text content.\r\n * Destructive keywords (delete, remove, cancel) â†’ destructiveHint.\r\n */\r\nfunction inferButtonAnnotations(element: ScannedElement): ToolAnnotations {\r\n    const text = (element.ariaLabel || element.textContent || \"\").toLowerCase();\r\n    const destructiveWords = [\"delete\", \"remove\", \"cancel\", \"destroy\", \"unsubscribe\"];\r\n    const readOnlyWords = [\"search\", \"view\", \"show\", \"filter\", \"browse\", \"find\"];\r\n\r\n    if (destructiveWords.some((w) => text.includes(w))) {\r\n        return { destructiveHint: true, readOnlyHint: false };\r\n    }\r\n    if (readOnlyWords.some((w) => text.includes(w))) {\r\n        return { readOnlyHint: true, destructiveHint: false };\r\n    }\r\n    return { idempotentHint: true };\r\n}\r\n\r\nfunction schemaFromButton(element: ScannedElement): ToolSchema {\r\n    const label =\r\n        element.ariaLabel || element.textContent || element.id || \"unknown_button\";\r\n    const name = element.overrideName ?? toToolName(label);\r\n    const description = element.overrideDescription ?? `Click the \"${label}\" button`;\r\n    const annotations = element.overrideAnnotations ?? inferButtonAnnotations(element);\r\n\r\n    return {\r\n        name,\r\n        description,\r\n        parameters: { type: \"object\", properties: {}, required: [] },\r\n        selector: element.selector,\r\n        elementType: \"button\",\r\n        annotations,\r\n    };\r\n}\r\n\r\n/**\r\n * Generate schemas locally from element metadata (no API call).\r\n */\r\nfunction generateLocalSchemas(elements: ScannedElement[]): ToolSchema[] {\r\n    const schemas: ToolSchema[] = [];\r\n    for (const element of elements) {\r\n        if (element.type === \"form\") {\r\n            schemas.push(schemaFromForm(element));\r\n        } else if (element.type === \"button\") {\r\n            schemas.push(schemaFromButton(element));\r\n        }\r\n    }\r\n    return schemas;\r\n}\r\n\r\n// â”€â”€â”€ Cache â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nconst CACHE_KEY_PREFIX = \"__3rdeye_schemas_\";\r\nconst CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\r\n\r\nfunction getCachedSchemas(): ToolSchema[] | null {\r\n    try {\r\n        if (typeof localStorage === \"undefined\") return null;\r\n\r\n        const key = CACHE_KEY_PREFIX + window.location.pathname;\r\n        const raw = localStorage.getItem(key);\r\n        if (!raw) return null;\r\n\r\n        const cached = JSON.parse(raw) as { schemas: ToolSchema[]; timestamp: number };\r\n        if (Date.now() - cached.timestamp > CACHE_TTL_MS) {\r\n            localStorage.removeItem(key);\r\n            return null;\r\n        }\r\n\r\n        log.info(\"ğŸ“¦ Using cached schemas\");\r\n        return cached.schemas;\r\n    } catch {\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction cacheSchemas(schemas: ToolSchema[]): void {\r\n    try {\r\n        if (typeof localStorage === \"undefined\") return;\r\n\r\n        const key = CACHE_KEY_PREFIX + window.location.pathname;\r\n        localStorage.setItem(\r\n            key,\r\n            JSON.stringify({ schemas, timestamp: Date.now() }),\r\n        );\r\n    } catch {\r\n        // Storage full or unavailable â€” silently ignore.\r\n    }\r\n}\r\n\r\n// â”€â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/**\r\n * Convert scanned DOM elements into WebMCP tool schemas.\r\n *\r\n * **Strategy:**\r\n *   1. Check localStorage cache first (unless skipCache is true)\r\n *   2. Try the 3rd Eye API (AI-enhanced via GPT-4o-mini)\r\n *   3. Fall back to local generation if API is unreachable\r\n *\r\n * @param elements   - The output of scanDOM().\r\n * @param endpoint   - API endpoint (e.g. \"http://localhost:3002\").\r\n * @param skipCache  - If true, bypass cache (used by watcher for delta re-scans).\r\n * @returns Array of ToolSchema.\r\n */\r\nexport async function fetchSchemas(\r\n    elements: ScannedElement[],\r\n    endpoint?: string,\r\n    skipCache = false,\r\n): Promise<ToolSchema[]> {\r\n    // â”€â”€ 1. Check cache â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n    if (!skipCache) {\r\n        const cached = getCachedSchemas();\r\n        if (cached) return cached;\r\n    }\r\n\r\n    // â”€â”€ 2. Skip API if every element has developer-provided overrides â”€â”€â”€â”€â”€â”€â”€\r\n    const allOverridden = elements.every((e) => e.overrideName && e.overrideDescription);\r\n    if (allOverridden) {\r\n        const schemas = generateLocalSchemas(elements);\r\n        log.info(\r\n            `ğŸ§  All ${schemas.length} element(s) have declarative overrides â€” skipping API`,\r\n            schemas,\r\n        );\r\n        return schemas;\r\n    }\r\n\r\n    // â”€â”€ 3. Try API (with 15s timeout) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n    if (endpoint) {\r\n        try {\r\n            const controller = new AbortController();\r\n            const timeoutId = setTimeout(() => controller.abort(), 15000);\r\n\r\n            const pageUrl =\r\n                typeof window !== \"undefined\" ? window.location.href : \"unknown\";\r\n\r\n            log.info(`ğŸ§  Requesting AI schemas from ${endpoint}...`);\r\n\r\n            const response = await fetch(`${endpoint}/api/v1/generate-schema`, {\r\n                method: \"POST\",\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({ pageUrl, elements }),\r\n                signal: controller.signal,\r\n            });\r\n\r\n            clearTimeout(timeoutId);\r\n\r\n            if (response.ok) {\r\n                const data = await response.json();\r\n                const schemas: ToolSchema[] = data.schemas ?? [];\r\n\r\n                if (schemas.length > 0) {\r\n                    const source = data.meta?.source ?? \"unknown\";\r\n                    log.info(\r\n                        `ğŸ§  Received ${schemas.length} schema(s) from API (source: ${source})`,\r\n                        schemas,\r\n                    );\r\n                    cacheSchemas(schemas);\r\n                    return schemas;\r\n                }\r\n            }\r\n\r\n            log.warn(`API returned ${response.status}, falling back to local.`);\r\n        } catch (err) {\r\n            if (err instanceof DOMException && err.name === \"AbortError\") {\r\n                log.warn(\"API request timed out (15s), falling back to local.\");\r\n            } else {\r\n                log.warn(\"API unreachable, falling back to local.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    // â”€â”€ 4. Local fallback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n    const schemas = generateLocalSchemas(elements);\r\n    log.info(`ğŸ§  Generated ${schemas.length} schema(s) locally (fallback)`, schemas);\r\n    return schemas;\r\n}\r\n","// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 3rd Eye SDK â€” Tool Registrar\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// The final step in the pipeline: take generated ToolSchemas and register them\r\n// with Chrome's WebMCP API (`navigator.modelContext.registerTool`).\r\n//\r\n// THE TRAP: Every `execute` callback is wrapped with a three-phase interceptor:\r\n//   1. Pre-execution  â†’ trackEvent(\"TOOL_ATTEMPT\")\r\n//   2. DOM interaction â†’ fill inputs + requestSubmit(), or click()\r\n//   3. Post-execution â†’ trackEvent(\"TOOL_SUCCESS\") or trackEvent(\"TOOL_ERROR\")\r\n//\r\n// ENTERPRISE FEATURES (v2):\r\n//   â€¢ Annotations (readOnlyHint, destructiveHint) passed to registerTool\r\n//   â€¢ requestUserInteraction for destructive tools (confirmation dialog)\r\n//   â€¢ unregisterTool when DOM elements are removed\r\n//   â€¢ Tool name â†” selector tracking for diffing\r\n//\r\n// The wrapper is wrapped in try/catch so a failure in OUR code never crashes\r\n// the customer's website.\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nimport type { ToolSchema, ModelContextClient } from \"./types\";\r\nimport { trackEvent } from \"./telemetry\";\r\nimport * as log from \"./logger\";\r\n\r\n// â”€â”€â”€ Tool Registry (name â†” selector mapping) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/** Map of registered tool names â†’ their CSS selectors. */\r\nconst registeredTools = new Map<string, string>();\r\n\r\n/** Get all currently registered tool names. */\r\nexport function getRegisteredToolNames(): Set<string> {\r\n    return new Set(registeredTools.keys());\r\n}\r\n\r\n/** Get the selector for a registered tool. */\r\nexport function getSelectorForTool(name: string): string | undefined {\r\n    return registeredTools.get(name);\r\n}\r\n\r\n// â”€â”€â”€ DOM Interaction Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/**\r\n * Programmatically fill a form's inputs with the given arguments, then\r\n * submit the form.\r\n *\r\n * @param form - The `<form>` DOM element.\r\n * @param args - Key/value pairs where key = input `name` and value = text.\r\n */\r\nfunction executeForm(form: HTMLFormElement, args: Record<string, string>): void {\r\n    for (const [name, value] of Object.entries(args)) {\r\n        const input = form.querySelector<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>(\r\n            `[name=\"${name}\"], #${CSS.escape(name)}`,\r\n        );\r\n\r\n        if (!input) {\r\n            log.warn(`Input \"${name}\" not found in form \"${form.id}\". Skipping.`);\r\n            continue;\r\n        }\r\n\r\n        // Set the value and dispatch an 'input' event so front-end frameworks\r\n        // (React, Vue, etc.) pick up the change.\r\n        const nativeInputValueSetter =\r\n            Object.getOwnPropertyDescriptor(\r\n                window.HTMLInputElement.prototype,\r\n                \"value\",\r\n            )?.set ??\r\n            Object.getOwnPropertyDescriptor(\r\n                window.HTMLTextAreaElement.prototype,\r\n                \"value\",\r\n            )?.set;\r\n\r\n        if (nativeInputValueSetter) {\r\n            nativeInputValueSetter.call(input, value);\r\n        } else {\r\n            input.value = value;\r\n        }\r\n\r\n        input.dispatchEvent(new Event(\"input\", { bubbles: true }));\r\n        input.dispatchEvent(new Event(\"change\", { bubbles: true }));\r\n    }\r\n\r\n    // Use requestSubmit() so the form's `submit` event fires (unlike .submit()).\r\n    if (typeof form.requestSubmit === \"function\") {\r\n        form.requestSubmit();\r\n    } else {\r\n        form.submit();\r\n    }\r\n}\r\n\r\n/**\r\n * Programmatically click a button element.\r\n */\r\nfunction executeButton(el: HTMLElement): void {\r\n    el.click();\r\n}\r\n\r\n// â”€â”€â”€ User Confirmation for Destructive Tools â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/**\r\n * If the tool is marked as destructive AND the client supports user\r\n * interaction, prompt the user for confirmation before executing.\r\n */\r\nasync function maybeConfirmDestructive(\r\n    schema: ToolSchema,\r\n    client?: ModelContextClient,\r\n): Promise<boolean> {\r\n    // Not destructive? Proceed without confirmation.\r\n    if (!schema.annotations?.destructiveHint) return true;\r\n\r\n    // No client? Can't request interaction â€” proceed with caution.\r\n    if (!client?.requestUserInteraction) {\r\n        log.warn(\r\n            `âš ï¸ Tool \"${schema.name}\" is destructive but client doesn't support confirmation.`,\r\n        );\r\n        return true;\r\n    }\r\n\r\n    try {\r\n        const result = await client.requestUserInteraction(async () => {\r\n            // This callback runs in the browser's confirmation UI context.\r\n            // The browser will show a native confirmation dialog.\r\n            return window.confirm(\r\n                `AI agent wants to perform: \"${schema.description}\"\\n\\n` +\r\n                `This action may modify or delete data. Allow?`,\r\n            );\r\n        });\r\n\r\n        const allowed = result === true;\r\n\r\n        trackEvent(\"USER_CONFIRMATION\", {\r\n            toolName: schema.name,\r\n            allowed,\r\n            destructive: true,\r\n        });\r\n\r\n        if (!allowed) {\r\n            log.info(`ğŸš« User denied execution of destructive tool \"${schema.name}\".`);\r\n        }\r\n\r\n        return allowed;\r\n    } catch (err) {\r\n        // If requestUserInteraction fails, fall back to allowing the action\r\n        // (browser may not support it yet).\r\n        log.warn(`requestUserInteraction failed for \"${schema.name}\":`, err);\r\n        return true;\r\n    }\r\n}\r\n\r\n// â”€â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/**\r\n * Register an array of tool schemas with the WebMCP API.\r\n *\r\n * Each tool's `execute` callback is wrapped with telemetry tracking,\r\n * user confirmation for destructive tools, and robust error handling.\r\n *\r\n * @param schemas - The tool schemas to register.\r\n */\r\nexport function registerTools(schemas: ToolSchema[]): void {\r\n    if (!navigator.modelContext) {\r\n        log.warn(\"Cannot register tools â€” navigator.modelContext is unavailable.\");\r\n        return;\r\n    }\r\n\r\n    let registered = 0;\r\n\r\n    for (const schema of schemas) {\r\n        // Skip if already registered (idempotent).\r\n        if (registeredTools.has(schema.name)) {\r\n            log.info(`Tool \"${schema.name}\" already registered. Skipping.`);\r\n            continue;\r\n        }\r\n\r\n        try {\r\n            navigator.modelContext.registerTool({\r\n                name: schema.name,\r\n                description: schema.description,\r\n                inputSchema: schema.parameters,\r\n\r\n                // â”€â”€ W3C Annotations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n                annotations: schema.annotations,\r\n\r\n                // â”€â”€ The Wrapped Execute Callback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n                execute: async (\r\n                    args: Record<string, string>,\r\n                    client?: ModelContextClient,\r\n                ): Promise<unknown> => {\r\n                    const startTime = Date.now();\r\n\r\n                    // Phase A: Telemetry â€” TOOL_ATTEMPT\r\n                    trackEvent(\"TOOL_ATTEMPT\", {\r\n                        toolName: schema.name,\r\n                        args,\r\n                    });\r\n\r\n                    try {\r\n                        // Phase B: User confirmation for destructive tools\r\n                        const allowed = await maybeConfirmDestructive(schema, client);\r\n                        if (!allowed) {\r\n                            return {\r\n                                success: false,\r\n                                toolName: schema.name,\r\n                                reason: \"User denied destructive action.\",\r\n                            };\r\n                        }\r\n\r\n                        // Phase C: DOM Interaction\r\n                        const el = document.querySelector(schema.selector);\r\n\r\n                        if (!el) {\r\n                            throw new Error(\r\n                                `Element not found for selector: ${schema.selector}`,\r\n                            );\r\n                        }\r\n\r\n                        if (schema.elementType === \"form\") {\r\n                            executeForm(el as HTMLFormElement, args);\r\n                        } else {\r\n                            executeButton(el as HTMLElement);\r\n                        }\r\n\r\n                        // Phase D: Telemetry â€” TOOL_SUCCESS\r\n                        const duration = Date.now() - startTime;\r\n                        trackEvent(\"TOOL_SUCCESS\", {\r\n                            toolName: schema.name,\r\n                            duration,\r\n                        });\r\n\r\n                        log.info(`âœ… Tool \"${schema.name}\" executed in ${duration}ms`);\r\n\r\n                        return {\r\n                            success: true,\r\n                            toolName: schema.name,\r\n                            duration,\r\n                        };\r\n                    } catch (err) {\r\n                        // Phase D (error): Telemetry â€” TOOL_ERROR\r\n                        const duration = Date.now() - startTime;\r\n                        const message =\r\n                            err instanceof Error ? err.message : \"Unknown error\";\r\n\r\n                        trackEvent(\"TOOL_ERROR\", {\r\n                            toolName: schema.name,\r\n                            error: message,\r\n                            duration,\r\n                        });\r\n\r\n                        log.error(`Tool \"${schema.name}\" failed:`, message);\r\n\r\n                        // Re-throw so the agent knows execution failed.\r\n                        throw err;\r\n                    }\r\n                },\r\n            });\r\n\r\n            // Track the registration\r\n            registeredTools.set(schema.name, schema.selector);\r\n            trackEvent(\"TOOL_REGISTERED\", { toolName: schema.name });\r\n            registered++;\r\n        } catch (err) {\r\n            // Guard: never crash the customer's page if registration itself fails.\r\n            log.error(`Failed to register tool \"${schema.name}\":`, err);\r\n        }\r\n    }\r\n\r\n    log.info(`ğŸš€ Registered ${registered}/${schemas.length} tool(s) with WebMCP`);\r\n}\r\n\r\n/**\r\n * Unregister tools whose selectors match removed DOM elements.\r\n *\r\n * @param removedSelectors - CSS selectors of elements that no longer exist.\r\n */\r\nexport function unregisterTools(removedSelectors: string[]): void {\r\n    if (!navigator.modelContext) return;\r\n\r\n    const removedSet = new Set(removedSelectors);\r\n\r\n    for (const [name, selector] of registeredTools) {\r\n        if (removedSet.has(selector)) {\r\n            try {\r\n                navigator.modelContext.unregisterTool(name);\r\n                registeredTools.delete(name);\r\n                trackEvent(\"TOOL_UNREGISTERED\", { toolName: name, selector });\r\n                log.info(`ğŸ—‘ï¸ Unregistered stale tool \"${name}\" (element removed)`);\r\n            } catch (err) {\r\n                log.error(`Failed to unregister tool \"${name}\":`, err);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Unregister ALL tools and clear the registry.\r\n * Used during SDK destroy / context clearing.\r\n */\r\nexport function unregisterAllTools(): void {\r\n    if (!navigator.modelContext) return;\r\n\r\n    for (const [name] of registeredTools) {\r\n        try {\r\n            navigator.modelContext.unregisterTool(name);\r\n        } catch {\r\n            // Best-effort cleanup.\r\n        }\r\n    }\r\n\r\n    const count = registeredTools.size;\r\n    registeredTools.clear();\r\n    log.info(`ğŸ—‘ï¸ Unregistered all ${count} tool(s)`);\r\n}\r\n","// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 3rd Eye SDK â€” Live DOM Watcher\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Uses MutationObserver to detect when elements are added or removed from the\r\n// DOM (modals, AJAX content, SPA route changes).  When changes are detected:\r\n//\r\n//   â€¢ NEW elements â†’ scan â†’ generate schemas â†’ register tools\r\n//   â€¢ REMOVED elements â†’ unregister stale tools\r\n//\r\n// Also listens for SPA navigation events (popstate, hashchange) to trigger\r\n// a full re-scan when the \"page\" changes without a real page load.\r\n//\r\n// All re-scans are DEBOUNCED (300ms) to avoid hammering the pipeline when\r\n// frameworks like React re-render dozens of nodes in rapid succession.\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nimport type { ScannedElement, ToolSchema, ThirdEyeConfig } from \"./types\";\r\nimport { scanDOM } from \"./scanner\";\r\nimport { fetchSchemas } from \"./schema\";\r\nimport { registerTools, unregisterTools, getRegisteredToolNames } from \"./registrar\";\r\nimport { trackEvent } from \"./telemetry\";\r\nimport * as log from \"./logger\";\r\n\r\n// â”€â”€â”€ Internal State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nlet observer: MutationObserver | null = null;\r\nlet debounceTimer: ReturnType<typeof setTimeout> | null = null;\r\nlet currentSelectors = new Set<string>();\r\nlet currentUrl = \"\";\r\nlet config: ThirdEyeConfig | null = null;\r\n\r\nconst DEBOUNCE_MS = 300;\r\n\r\n// â”€â”€â”€ Diffing Logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/**\r\n * Compare old selectors with new scanned elements to find what was\r\n * added and what was removed.\r\n */\r\nfunction diffSelectors(\r\n    newElements: ScannedElement[],\r\n): { added: ScannedElement[]; removedSelectors: string[] } {\r\n    const newSelectors = new Set(newElements.map((e) => e.selector));\r\n\r\n    const added = newElements.filter((e) => !currentSelectors.has(e.selector));\r\n    const removedSelectors = [...currentSelectors].filter(\r\n        (sel) => !newSelectors.has(sel),\r\n    );\r\n\r\n    return { added, removedSelectors };\r\n}\r\n\r\n// â”€â”€â”€ Re-scan Pipeline â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/**\r\n * Debounced re-scan triggered by DOM mutations or SPA navigation.\r\n * Only processes the DIFF â€” doesn't re-register tools that already exist.\r\n */\r\nasync function handleDOMChange(reason: \"mutation\" | \"navigation\"): Promise<void> {\r\n    if (!config) return;\r\n\r\n    try {\r\n        // Step 1: Re-scan the entire DOM\r\n        const allElements = scanDOM();\r\n        const { added, removedSelectors } = diffSelectors(allElements);\r\n\r\n        // Nothing changed? Bail early.\r\n        if (added.length === 0 && removedSelectors.length === 0) return;\r\n\r\n        log.info(\r\n            `ğŸ”„ DOM ${reason}: +${added.length} new, -${removedSelectors.length} removed`,\r\n        );\r\n\r\n        trackEvent(\"DOM_MUTATION\", {\r\n            reason,\r\n            added: added.length,\r\n            removed: removedSelectors.length,\r\n        });\r\n\r\n        // Step 2: Unregister tools for REMOVED elements\r\n        if (removedSelectors.length > 0) {\r\n            // Find tool names that map to removed selectors\r\n            const registeredNames = getRegisteredToolNames();\r\n            // We need to find which tool names correspond to removed selectors\r\n            // The registrar tracks nameâ†”selector mapping\r\n            unregisterTools(removedSelectors);\r\n        }\r\n\r\n        // Step 3: Register tools for NEW elements\r\n        if (added.length > 0) {\r\n            const newSchemas = await fetchSchemas(added, config.endpoint, true);\r\n            registerTools(newSchemas);\r\n        }\r\n\r\n        // Update the current state\r\n        currentSelectors = new Set(allElements.map((e) => e.selector));\r\n    } catch (err) {\r\n        log.error(\"Watcher re-scan failed:\", err);\r\n    }\r\n}\r\n\r\n/**\r\n * Debounced trigger â€” waits for mutations to settle before re-scanning.\r\n */\r\nfunction debouncedRescan(reason: \"mutation\" | \"navigation\"): void {\r\n    if (debounceTimer) clearTimeout(debounceTimer);\r\n    debounceTimer = setTimeout(() => handleDOMChange(reason), DEBOUNCE_MS);\r\n}\r\n\r\n// â”€â”€â”€ SPA Navigation Handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nfunction handleNavigation(): void {\r\n    const newUrl = window.location.href;\r\n    if (newUrl === currentUrl) return;\r\n\r\n    log.info(`ğŸ§­ SPA navigation detected: ${currentUrl} â†’ ${newUrl}`);\r\n    trackEvent(\"SPA_NAVIGATE\", { from: currentUrl, to: newUrl });\r\n    currentUrl = newUrl;\r\n\r\n    debouncedRescan(\"navigation\");\r\n}\r\n\r\n// â”€â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n/**\r\n * Start watching for DOM changes and SPA navigation events.\r\n *\r\n * Call this AFTER the initial scan + register cycle completes.\r\n *\r\n * @param sdkConfig - The SDK configuration (needed for API endpoint).\r\n * @param initialSelectors - Selectors from the initial scan.\r\n */\r\nexport function startWatching(\r\n    sdkConfig: ThirdEyeConfig,\r\n    initialSelectors: string[],\r\n): void {\r\n    if (observer) {\r\n        log.warn(\"Watcher already running.\");\r\n        return;\r\n    }\r\n\r\n    config = sdkConfig;\r\n    currentSelectors = new Set(initialSelectors);\r\n    currentUrl = window.location.href;\r\n\r\n    // â”€â”€ MutationObserver â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n    observer = new MutationObserver((mutations) => {\r\n        // Quick check: did any mutation actually add or remove element nodes?\r\n        const hasRelevantChange = mutations.some((m) =>\r\n            m.addedNodes.length > 0 || m.removedNodes.length > 0,\r\n        );\r\n\r\n        if (hasRelevantChange) {\r\n            debouncedRescan(\"mutation\");\r\n        }\r\n    });\r\n\r\n    observer.observe(document.body, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n\r\n    // â”€â”€ SPA Navigation Events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n    window.addEventListener(\"popstate\", handleNavigation);\r\n    window.addEventListener(\"hashchange\", handleNavigation);\r\n\r\n    log.info(\"ğŸ‘ï¸ Live watcher started (MutationObserver + SPA navigation)\");\r\n}\r\n\r\n/**\r\n * Stop watching and clean up all event listeners.\r\n */\r\nexport function stopWatching(): void {\r\n    if (observer) {\r\n        observer.disconnect();\r\n        observer = null;\r\n    }\r\n\r\n    if (debounceTimer) {\r\n        clearTimeout(debounceTimer);\r\n        debounceTimer = null;\r\n    }\r\n\r\n    window.removeEventListener(\"popstate\", handleNavigation);\r\n    window.removeEventListener(\"hashchange\", handleNavigation);\r\n\r\n    currentSelectors.clear();\r\n    config = null;\r\n\r\n    log.info(\"ğŸ‘ï¸ Live watcher stopped\");\r\n}\r\n\r\n/**\r\n * Check if the watcher is currently active.\r\n */\r\nexport function isWatching(): boolean {\r\n    return observer !== null;\r\n}\r\n"],"mappings":"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","names":["src_exports","__export","ThirdEyeSDK","src_default","destroy","getConfig","getScannedElements","getSchemas","init","isInitialized","isWatcherActive","scan","PREFIX","debugEnabled","setDebug","enabled","info","args","warn","error","DEFAULT_INGEST_URL","siteId","ingestUrl","configureTelemetry","id","url","trackEvent","name","data","event","payload","blob","info","warn","buildSelector","el","tag","parent","siblings","s","idx","findLabelText","input","label","STANDARD_SELECTORS","isIgnored","readToolAttributes","name","description","hasReadOnly","hasDestructive","hasIdempotent","hasOpenWorld","annotations","scanForms","forms","results","form","overrides","inputEls","inputs","overrideParamDescription","scanButtons","candidates","ariaLabel","textContent","id","scanAnnotated","scanDOM","buttons","annotated","all","info","toToolName","raw","inputsToSchema","element","properties","required","input","inferFormAnnotations","method","m","schemaFromForm","name","inputCount","description","annotations","inferButtonAnnotations","text","destructiveWords","readOnlyWords","w","schemaFromButton","label","generateLocalSchemas","elements","schemas","CACHE_KEY_PREFIX","CACHE_TTL_MS","getCachedSchemas","key","cached","info","cacheSchemas","fetchSchemas","endpoint","skipCache","e","controller","timeoutId","pageUrl","response","data","source","warn","err","registeredTools","getRegisteredToolNames","executeForm","form","args","name","value","input","warn","nativeInputValueSetter","executeButton","el","maybeConfirmDestructive","schema","client","allowed","trackEvent","info","err","registerTools","schemas","registered","registeredTools","startTime","duration","message","error","unregisterTools","removedSelectors","removedSet","selector","unregisterAllTools","count","observer","debounceTimer","currentSelectors","currentUrl","config","DEBOUNCE_MS","diffSelectors","newElements","newSelectors","e","added","removedSelectors","sel","handleDOMChange","reason","allElements","scanDOM","info","trackEvent","registeredNames","getRegisteredToolNames","unregisterTools","newSchemas","fetchSchemas","registerTools","err","error","debouncedRescan","handleNavigation","newUrl","startWatching","sdkConfig","initialSelectors","warn","mutations","m","stopWatching","isWatching","ThirdEyeSDK","config","warn","error","setDebug","configureTelemetry","info","trackEvent","scanDOM","fetchSchemas","registerTools","selectors","e","startWatching","err","meta","isWatching","stopWatching","unregisterAllTools","instance","init","scan","destroy","isInitialized","getConfig","getScannedElements","getSchemas","isWatcherActive","src_default","script","siteId"]}